{
  "hash": "3987d1923d621d5ca9406e07fd59b1a5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Disease Mapping\"\nauthor: \"Prof. Sam Berchuck\"\ndate: \"2025-03-25\"\ndate-format: \"MMM DD, YYYY\"\nfooter: \"[ðŸ”— BIOSTAT 725 - Spring 2025](https://biostat725-sp25.netlify.app/)\"\nlogo: \"../images/logo.png\"\nformat: \n  revealjs:\n    theme: slides.scss\n    multiplex: false\n    transition: fade\n    slide-number: true\n    incremental: false \n    chalkboard: true\n    html-math-method: mathjax\nfilters:\n  - parse-latex\nexecute:\n  freeze: auto\n  echo: true\nknitr:\n  opts_chunk: \n    R.options:      \n    width: 200\nbibliography: references.bib\n---\n\n::: {.cell}\n\n:::\n\n\n\n## Review of last lecture\n\n-   During our last lecture, we learned about Gaussian processes.\n\n-   We learned how to apply Gaussian processes to longitudinal (or time-series) data.\n\n-   The longitudinal setting is one-dimensional (i.e., time). Today we will learn about applying Gaussian processes in two-dimensions (i.e. space).\n\n## Goal of an Areal Data Spatial Analysis\n\n- Account for noise due to spatial variability in order to provide smoothed estimates across space\n\n\n\n::: {.cell layout-ncol=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](19-disease-mapping_files/figure-revealjs/unnamed-chunk-2-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Motivating Data\n\n\n\n## Spatial Correlation: Areal Data\n\n- How to induce spatial correlation between areal units? \n\t\n  - Distances between centroids (possibly population weighted); may be inappropriate for oddly shaped regions of varying sizes (great for equal sized grid though).\n\n  - Neighborhood structure of your spatial region; are two regions neighbors?\n  \n- Correlation introduced through spatial random effects.\n\n## Bayesian Model Fitting\n\n- CAR models are preferred in the Bayesian setting due to the conditional definition of the model\n\n- $\\theta_i$ parameters are typically updated individually.\n\n- Depending on the likelihood, conjugacy may be available, useful for Gibbs sampling.\n\n- Today, CAR models can be implemented using probabilistic programming languages (e.g., Stan).\n\n## Inducing Spatial Dependency\n\nThe most common approach for inducing spatial dependency in an areal data setting using the intrinsic conditional autoregressive (ICAR) process,\n\n$$\\boldsymbol{\\theta} | \\tau^2 \\sim \\text{ICAR}\\left(\\tau^2\\right)$$\n\n$$\\theta_{i} | \\boldsymbol{\\theta}_{-i}, \\tau^2 \\sim \\mathcal N \\left({\\frac{\\sum_{j=1}^n w_{ij}\\theta_{j}}{\\sum_{j=1}^n w_{ij}}},\\frac{\\tau^2}{\\sum_{j=1}^n w_{ij}}\\right)$$\n\n- $\\boldsymbol\\theta_{-j}$: Vector of $\\theta_{i}$ parameters with $\\theta_{j}$ removed\n\n- $\\boldsymbol{\\beta}_0 | \\tau_0^2 \\sim \\text{ICAR}\\left(\\tau_0^2\\right),\\quad \\boldsymbol{\\beta}_1 | \\tau_1^2 \\sim \\text{ICAR}\\left(\\tau_1^2\\right)$\n\n- Not a proper prior distribution (implications for MCMC algorithms!)\n\n## A Proper CAR Process\n\n$$\\boldsymbol{\\theta} = \\left\\{\\theta_1, \\ldots, \\theta_n\\right\\}^{\\text{T}};\\  \\boldsymbol{\\theta} | \\rho, \\tau^2 \\sim \\text{Leroux CAR}\\left(\\rho,\\tau^2\\right)$$\n\n$$\\theta_i | \\boldsymbol{\\theta}_{-i}, \\rho, \\tau^2 \\sim \\mathcal N \\left({\\frac{\\rho \\sum_{j=1}^n w_{ij} \\theta_j}{\\rho \\sum_{j=1}^n w_{ij} + 1 - \\rho}}, \\frac{\\tau^2}{\\rho \\sum_{j=1}^n w_{ij} + 1 - \\rho}\\right)$$\n\n- Proper for $\\rho \\in [0,1)$\n\n- $\\rho=1$ gives us the ICAR model\n\n  - $\\rho$ is given a prior distribution and estimated by the data\n  \n  - $\\text{COR}(\\theta_k,\\theta_j|\\boldsymbol{\\theta}_{-kj}) = \\frac{\\rho w_{kj}}{\\sqrt{(\\rho \\sum_{i=1}^n w_{ki} + 1 - \\rho)(\\rho \\sum_{i=1}^n w_{ji} + 1-\\rho)}}$\n\n## Prepare for next class\n\n-   Work on HW 04, which is due before class on Tuesday.\n\n-   Complete reading to prepare for next Tuesday's lecture\n\n-   Tuesday's lecture: Disease mapping\n",
    "supporting": [
      "19-disease-mapping_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}