{
  "hash": "0cabb1455eae96ffb4c9b4a47857537d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian Workflow\"\nauthor: \"Prof. Sam Berchuck\"\ndate: \"2025-02-04\"\ndate-format: \"MMM DD, YYYY\"\nfooter: \"[ðŸ”— BIOSTAT 725 - Spring 2025](https://biostat725-sp25.netlify.app/)\"\nlogo: \"../images/logo.png\"\nformat: \n  revealjs:\n    theme: slides.scss\n    multiplex: false\n    transition: fade\n    slide-number: true\n    incremental: false \n    chalkboard: true\n    html-math-method: mathjax\nfilters:\n  - parse-latex\nexecute:\n  freeze: auto\n  echo: true\nknitr:\n  opts_chunk: \n    R.options:      \n    width: 200\nbibliography: references.bib\n---\n\n::: {.cell}\n\n:::\n\n\n\n## Review of last lecture\n\nOn Thursday, we learned about various ways compare models.\n\n-   AIC, DIC, WAIC\n\n-   LOO-CV/LOO-IC\n\nToday, we will put these concepts within the larger framework of the Bayesian workflow.\n\n## Bayes theorem\n\n$$f(\\boldsymbol{\\theta} | \\mathbf{Y}) = \\frac{f(\\mathbf{Y} | \\boldsymbol{\\theta})f(\\boldsymbol{\\theta})}{f(\\mathbf{Y})}$$\n\n. . .\n\n\n- Rethinking Bayes theorem:\n\n$$f(\\boldsymbol{\\theta} | \\mathbf{Y}) \\propto f(\\mathbf{Y}, \\boldsymbol{\\theta}) = f(\\mathbf{Y} | \\boldsymbol{\\theta})f(\\boldsymbol{\\theta}) $$\n\n. . .\n\n- In Stan:\n\n$$\\log f(\\mathbf{Y} | \\boldsymbol{\\theta}) + \\log f(\\boldsymbol{\\theta})$$\n\n<!-- ## Bayesian statistics -->\n\n<!-- Advantages: -->\n\n<!-- - Natural approach to expressing uncertainty -->\n\n<!-- - Ability to incorporate prior information -->\n\n<!-- - Increased modeling flexibility -->\n\n<!-- - Full posterior distribution of parameters -->\n\n<!-- - Natural propagation of uncertainty -->\n\n<!-- Disadvantages: -->\n\n<!-- - Slow speed of model estimation -->\n\n## Bayesian workflow {.smaller}\n\n![](images/07/workflow.png){fig-alt=\"workflow\" fig-align=\"center\" height=\"5in\"}\n\n[Gelman A., Vehtari A., Simpson D., Margossian, C., Carpenter, B. and Yao, Y., Kennedy, L., Gabry, J., BÃ¼rkner P. C., & ModrÃ¡k M. (2020). Bayesian Workflow.](https://arxiv.org/abs/2011.01808)\n\n## Bayesian workflow\n\n![[Taken from Bayesian workflow by Francesca Capel](https://francescacapel.com/BayesianWorkflow/index.html)](images/07/workflow0.png){fig-alt=\"workflow0\" fig-align=\"center\" height=\"4in\"}\n\n- Today we will talk about a general strategy for taking a question and data to a robust conclusion.\n\n## A simplified workflow {.midi}\n\n1. *Setting up a full probability model:* a joint probability distribution for all observable and unobservable quantities in a problem. The model should be consistent with knowledge about the underlying scientific problem and the data collection process.\n\n2. *Conditioning on observed data:* calculating and interpreting the appropriate posterior distribution â€” the conditional probability distribution of the unobserved quantities of ultimate interest, given the observed data.\n\n3. *Evaluating the fit of the model and the implications of the resulting posterior distribution:* how well does the model fit the data, are the substantive conclusions reasonable, and how sensitive are the results to the modeling assumptions in step 1? In response, one can alter or expand the model and repeat the three steps.\n\n- From BDA3.\n\n## Bayesian workflow\n\n1. **Research question:** What are your dependent and indepednent variables? What associations are you interested in? EDA.\n\n. . .\n\n2. **Specify likelihood & priors:** Use knowledge of the problem to construct a generative model.\n\n. . .\n\n3. **Check the model with simulated data:** Generate data from the model and evaluate fit as a sanity check (prior predictive checks).\n\n. . .\n\n4. **Fit the model to real data:** Estimate parameters using MCMC.\n\n## Bayesian workflow\n\n5. **Check diagnostics:** Use MCMC diagnostics to guarentee that the algorithm converged.\n\n. . .\n\n6. **Examine posterior fit:** Create posterior summaries that are relevant to the research question. \n\n. . .\n\n7. **Check predictions:** Examing posterior predictive checks.\n\n. . .\n\n8. **Compare models:** Iterate on model design and choose a model.\n\n## Motivating example: predicting weight from height {.midi}\n\n**Research question:** We would like to understand the relationship between a person's height and weight. A few particular questions we have are:\n\n  1. How much does a person's weight increase when their height increases? \n  \n  2. How certain we can be about the magnitude of the increase?\n  \n  3. Can we predict a personâ€™s weight based on their height?\n\n**Data:** We will use the `bdims` dataset from the `openintro` package. This dataset contains body girth measurements and skeletal diameter measurements, as well as age, weight, height and gender.\n\n## Prepare data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(openintro)\ndat <- data.frame(weight = bdims$wgt * 2.20462, # convert weight to lbs\n                  height = bdims$hgt * 0.393701, # convert height to inches\n                  sex = ifelse(bdims$sex == 1, \"Male\", \"Female\"))\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    weight   height  sex\n1 144.6231 68.50397 Male\n2 158.2917 69.01579 Male\n3 177.9128 76.18114 Male\n4 160.0554 73.42524 Male\n5 173.7241 73.70083 Male\n6 164.9056 71.45673 Male\n```\n\n\n:::\n:::\n\n\n\n## 1. **Research question:**\n\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-3-1.png){fig-align='center' width=384}\n:::\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-3-2.png){fig-align='center' width=384}\n:::\n:::\n\n\n\n## 1. **Research question:**\n\n\n\n::: {.cell layout-ncol=\"2\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-4-1.png){fig-align='center' width=480}\n:::\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-4-2.png){fig-align='center' width=480}\n:::\n:::\n\n\n\n## 1. **Research question:**\n\n\n\n::: {.cell layout-ncol=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=480}\n:::\n:::\n\n\n\n## 2. **Specify likelihood & priors:**\n\n- Construct a data generating process. \n\n- We would like to model weight as a function of height using a linear regression model.\n\n$$weight_i = \\alpha + \\beta \\times height_i + \\epsilon_i,\\quad \\epsilon_i \\sim N(0,\\sigma^2)$$\n\n\n\n::: {.cell output.var='workflow'}\n\n```{.stan .cell-code}\ndata {\n  int<lower = 1> n;\n  vector[n] height;\n  vector[n] weight;\n}\n```\n:::\n\n\n\n## 2. **Specify likelihood & priors:**\n\n- Construct a data generating process. \n\n- We would like to model weight as a function of height using a linear regression model.\n\n$$weight_i = \\alpha + \\beta \\times height_i + \\epsilon_i,\\quad \\epsilon_i \\sim N(0,\\sigma^2)$$\n\n\n\n::: {.cell output.var='workflow'}\n\n```{.stan .cell-code}\nparameter {\n  real alpha;\n  real beta;\n  real<lower = 0> sigma;\n}\n```\n:::\n\n\n\n## 2. **Specify likelihood & priors:**\n\n- Construct a data generating process. \n\n- We would like to model weight as a function of height using a linear regression model.\n\n$$weight_i = \\alpha + \\beta \\times height_i + \\epsilon_i,\\quad \\epsilon_i \\sim N(0,\\sigma^2)$$\n\n\n\n::: {.cell output.var='workflow'}\n\n```{.stan .cell-code}\nmodel {\n  target += normal_lpdf(weight | alpha + beta * height, sigma);\n}\n```\n:::\n\n\n\n## 2. **Specify likelihood & priors:** {.midi}\n\n$$weight_i = \\alpha + \\beta \\times height_i + \\epsilon_i,\\quad \\epsilon_i \\sim N(0,\\sigma^2)$$\n\nThink about reasonable priors for your parameters:\n\n- $\\alpha$ is the intercept, or average weight for someone who is zero inches (not a particularly useful number on its own)\n\n- $\\beta$ measures the association between weight and height, in pounds/inch\n\n- $\\sigma$ is the measurement error for the population\n\n\n\n::: {.cell output.var='workflow'}\n\n```{.stan .cell-code}\nmodel {\n  target += normal_lpdf(weight | alpha + beta * height, sigma);\n  target += normal_lpdf(alpha | 0, 100);\n  target += normal_lpdf(beta | 0, 10);\n  target += normal_lpdf(sigma | 0, 5);\n}\n```\n:::\n\n\n\n## 2. **Specify likelihood & priors:** {.midi}\n\n$$\\mathbb{E}[weight_i] = \\alpha + \\beta \\times (height_i - \\bar{x)},\\quad\\bar{x}=\\frac{1}{n}\\sum_{i=1}^n height_i$$\n\nThink about reasonable priors for your parameters:\n\n- $\\alpha$ is the intercept, or average weight for someone who is an average height\n\n\n\n::: {.cell output.var='workflow'}\n\n```{.stan .cell-code}\nmodel {\n  target += normal_lpdf(weight | alpha + beta * height_c, sigma);\n  target += normal_lpdf(alpha | 150, 5);\n  target += normal_lpdf(beta | 0, 10);\n  target += normal_lpdf(sigma | 0, 5);\n}\n```\n:::\n\n\n\n## Quick aside\n\nWhat does it mean to use the prior `sigma ~ normal(0, 5)`? \n\n- When a parameter is truncated, for example `real<lower = 0> sigma`, priors can still be placed across the real line, $\\mathbb{R}$.\n\n\n\n::: {.cell output.var='workflow'}\n\n```{.stan .cell-code}\nparameters {\n  real<lower = 0> sigma;\n}\nmodel {\n  target += normal_lpdf(sigma | 0, 5);\n}\n```\n:::\n\n\n\n- This specification induces a prior on the truncated space $\\mathbb{R}^+$. \n\n- The induced prior for `sigma` is a [half-normal distribution](https://en.wikipedia.org/wiki/Half-normal_distribution).\n\n## Quick aside\n\n- The half-normal is a useful prior for nonnegative parameters that should not be too large and may be very close to zero. \n\n- Similar distributions for scale parameters are [half-t](https://en.wikipedia.org/wiki/Folded-t_and_half-t_distributions) and [half-Cauchy](https://distribution-explorer.github.io/continuous/halfcauchy.html) priors, these have heavier tales.\n\n\n::: {.cell layout-ncol=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-12-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n\n## 3. **Check the model with simulated data:** {.small}\n\n  1. Draw parameter values from priors.\n\n  2. Generate data based on those parameter values.\n\n  3. Fit model to generated data.\n\n  4. Check fit is reasonable.\n\n\n\n::: {.cell output.var='workflow'}\n\n```{.stan .cell-code}\ndata {\n  int<lower=0> n;\n  vector[n] height_c;\n}\ngenerated quantities {\n  vector[n] weight;\n  real alpha = normal_rng(150, 5);\n  real beta = normal_rng(0, 10);\n  real sigma = fabs(normal_rng(0, 5));\n  for (i in 1:n) {\n    weight[i] = normal_rng(alpha + beta * height_c[i], sigma);\n  }\n}\n```\n:::\n\n\n\n- Need `algorithm = \"Fixed_param\"`.\n\n## 3. **Check the model with simulated data:**\n\n\n\n::: {.cell layout-ncol=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-14-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n\n## 4. **Fit the model to real data:** {.midi}\n\n\n\n::: {.cell output.var='workflow'}\n\n```{.stan .cell-code}\n// saved in linear_regression_workflow.stan\ndata {\n  int<lower = 1> n; // number of observations\n  vector[n] weight; // outcome vector\n  vector[n] height_c; // covariate vector\n  int<lower = 1> n_pred; // number of new observations\n  vector[n_pred] height_c_pred; // vector for new observations\n}\nparameters {\n  real alpha;\n  real beta;\n  real<lower = 0> sigma;\n}\nmodel {\n  target += normal_lpdf(weight | alpha + height_c * beta, sigma); // likelihood\n  target += normal_lpdf(alpha | 150, 5);\n  target += normal_lpdf(beta | 0, 10);\n  target += normal_lpdf(sigma | 0, 5);\n}\ngenerated quantities {\n  vector[n] in_sample;\n  vector[n_pred] out_sample;\n  vector[n] log_lik;\n  for (i in 1:n) {\n    in_sample[i] = normal_rng(alpha + height_c[i] * beta, sigma);\n    log_lik[i] = normal_lpdf(weight[i] | alpha + height_c[i] * beta, sigma);\n  }\n  for (i in 1:n_pred) {\n    out_sample[i] = normal_rng(alpha + height_c_pred[i] * beta, sigma);\n  }\n}\n```\n:::\n\n\n\n## 4. **Fit the model to real data:** {.midi}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstan_data <- list(n = nrow(dat), \n                  height_c = (dat$height - mean(dat$height)), \n                  weight = dat$weight)\nregression_model <- stan_model(file = \"linear_regression_workflow.stan\")\nfit <- sampling(regression_model, data = stan_data)\nprint(fit)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nInference for Stan model: anon_model.\n4 chains, each with iter=2000; warmup=1000; thin=1; \npost-warmup draws per chain=1000, total post-warmup draws=4000.\n\n        mean se_mean   sd   2.5%    50%  97.5% n_eff Rhat\nalpha 152.35    0.01 0.88 150.63 152.35 154.08  3773    1\nbeta    5.69    0.00 0.25   5.21   5.69   6.18  4215    1\nsigma  20.25    0.01 0.60  19.13  20.23  21.50  3571    1\n\nSamples were drawn using NUTS(diag_e) at Wed Nov 27 14:08:19 2024.\nFor each parameter, n_eff is a crude measure of effective sample size,\nand Rhat is the potential scale reduction factor on split chains (at \nconvergence, Rhat=1).\n```\n\n\n:::\n:::\n\n\n\n## 5. **Check diagnostics:**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstan::traceplot(fit, pars = c(\"alpha\", \"beta\", \"sigma\"))\n```\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-18-1.png){width=960}\n:::\n:::\n\n\n\n## 5. **Check diagnostics:**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bayesplot)\nmcmc_acf(fit, regex_pars = c(\"alpha\", \"beta\", \"sigma\"))\n```\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-19-1.png){width=960}\n:::\n:::\n\n\n\n## 6. **Examine posterior fit:**\n\n\n\n::: {.cell layout-ncol=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-20-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n\n## 6. **Examine posterior fit:**\n\n\n\n::: {.cell layout-ncol=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-21-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nRegression line corresponds to posterior mean and 95% credible interval for $\\mu = \\alpha + \\beta \\times height_i$.\n\n## 7.**Check predictions:**\n\n\n\n::: {.cell layout-nrow=\"1\" layout-align=\"center\"}\n\n```{.r .cell-code}\ny_pred <- rstan::extract(fit, pars = \"in_sample\")$in_sample\nppc_dens_overlay(dat$weight, y_pred[1:100, ])\n```\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-22-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## 7. **Check predictions:** {.midi}\n\n\n\n::: {.cell layout-nrow=\"2\" layout-ncol=\"2\" layout-align=\"center\"}\n\n```{.r .cell-code}\nppc_stat(dat$weight, y_pred, stat = \"mean\") # from bayesplot\n```\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-23-1.png){fig-align='center' width=384}\n:::\n\n```{.r .cell-code}\nppc_stat(dat$weight, y_pred, stat = \"sd\")\n```\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-23-2.png){fig-align='center' width=384}\n:::\n\n```{.r .cell-code}\nq025 <- function(y) quantile(y, 0.025)\nq975 <- function(y) quantile(y, 0.975)\nppc_stat(dat$weight, y_pred, stat = \"q025\")\n```\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-23-3.png){fig-align='center' width=384}\n:::\n\n```{.r .cell-code}\nppc_stat(dat$weight, y_pred, stat = \"q975\")\n```\n\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-23-4.png){fig-align='center' width=384}\n:::\n:::\n\n\n\n## 7. **Check predictions:** {.midi}\n\n\n\n::: {.cell layout-ncol=\"1\" layout-align=\"center\"}\n::: {.cell-output-display}\n![](08-workflow_files/figure-revealjs/unnamed-chunk-24-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nRegression line corresponds to posterior predictive distribution mean and 95% credible interval, $f(weight_{i'} | weight_{1:n})$.\n\n## `shinystan`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shinystan)\ny <- dat$weight # need to define outcome as a global variable to be accessible\nsso <- shinystan::launch_shinystan(fit)\n```\n:::\n\n\n\n## 8. Compare models\n\n- Suppose we would like to compare our original model with models that also includes sex and an interaction between sex and height.\n\n\\begin{align*}\n\\mathbb{E}[weight_i] &= \\alpha + \\beta_1 height_i\\\\\n\\mathbb{E}[weight_i] &= \\alpha + \\beta_1 height_i + \\beta_2 sex_i\\\\\n\\mathbb{E}[weight_i] &= \\alpha + \\beta_1 height_i + \\beta_2 sex_i + \\beta_3 height_i sex_i\n\\end{align*}\n\n## 8. Compare models {.midi}\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n###Compute individual WAIC\nlibrary(loo)\nlog_lik_model1 <- loo::extract_log_lik(fit_model1, parameter_name = \"log_lik\", merge_chains = TRUE)\nlog_lik_model2 <- loo::extract_log_lik(fit_model2, parameter_name = \"log_lik\", merge_chains = TRUE)\nlog_lik_model3 <- loo::extract_log_lik(fit_model3, parameter_name = \"log_lik\", merge_chains = TRUE)\nwaic_model1 <- loo::waic(log_lik_model1)\nwaic_model2 <- loo::waic(log_lik_model2)\nwaic_model3 <- loo::waic(log_lik_model3)\n\n###Make a comparison\ncomp_waic <- loo::loo_compare(list(\"height_only\" = waic_model1, \"height_sex\" = waic_model2, \"interaction\" = waic_model3))\nprint(comp_waic, digits = 2, simplify = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            elpd_diff se_diff  elpd_waic se_elpd_waic p_waic   se_p_waic\nheight_sex      0.00      0.00 -2229.19     23.36         4.84     0.88 \ninteraction    -0.82      2.41 -2230.02     23.44         5.70     0.97 \nheight_only   -25.33      5.80 -2254.52     21.32         3.54     0.62 \n            waic     se_waic \nheight_sex   4458.39    46.73\ninteraction  4460.04    46.88\nheight_only  4509.04    42.64\n```\n\n\n:::\n:::\n\n\n\n## 8. Compare models {.midi}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n###Compute individual LOO-CV/LOO-IC\nloo_model1 <- loo::loo(log_lik_model1)\nloo_model2 <- loo::loo(log_lik_model2)\nloo_model3 <- loo::loo(log_lik_model3)\n\n###Make a comparison\ncomp_loo <- loo::loo_compare(list(\"height_only\" = loo_model1, \"height_sex\" = loo_model2, \"interaction\" = loo_model3))\nprint(comp_loo, digits = 2, simplify = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            elpd_diff se_diff  elpd_loo se_elpd_loo p_loo    se_p_loo looic   \nheight_sex      0.00      0.00 -2229.21    23.37        4.85     0.89  4458.41\ninteraction    -0.83      2.41 -2230.03    23.44        5.72     0.97  4460.06\nheight_only   -25.32      5.80 -2254.52    21.32        3.55     0.62  4509.05\n            se_looic\nheight_sex     46.74\ninteraction    46.89\nheight_only    42.64\n```\n\n\n:::\n:::\n\n\n\n## The plan moving forward\n\n- We have now learned all of the skills needed to implement a Bayesian workflow.\n\n- The remainder of the course will be focused on introducing new models for types of data that are common when working in the biomedical data setting. \n\n## Prepare for next class\n\n-   Work on [HW 02](https://biostat725-sp25.netlify.app/hw/hw-02)\n\n-   Complete reading to prepare for next Thursday's lecture\n\n-   Thursday's lecture: Nonlinear Regression\n",
    "supporting": [
      "08-workflow_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}